package domain

import (
	"testing"

	"github.com/davidenq/tweets-timeline-challenge/app/domain/schemas"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
)

type testSchema struct {
	description    string
	EntityName     EntityName
	data           []byte
	check          bool
	expectedEntity EntityPort
	expectedError  bool
}

var (
	uuid4         = uuid.New()
	emptyData     []byte
	malFormedData = []byte(`{id":"` + uuid4.String() + `"}`)
	fakeData      = []byte(`{"id":"` + uuid4.String() + `"}`)
	badData       = []byte(`{"id":"baddata"}`)
)

func TestGetSchema(t *testing.T) {

	tests := []testSchema{
		{
			description:    "should return a schema with empty oauth entity and nil error",
			EntityName:     OAuth,
			expectedEntity: &schemas.OAuthSchema{},
		},
		{
			description:    "should return a schema with empty profile schema and nil error",
			EntityName:     Profile,
			expectedEntity: &schemas.ProfileSchema{},
		},
		{
			description:    "should return a schema with empty tweets schema and nil error",
			EntityName:     Tweets,
			expectedEntity: &schemas.TweetsSchema{},
		},
		{
			description:    "should return a schema with empty user schema and nil error",
			EntityName:     User,
			expectedEntity: &schemas.UserSchema{},
		},

		{
			description:    "should return a schema with nil entity and an error generated by non available entityName",
			EntityName:     "NonAvailable",
			expectedEntity: nil,
			expectedError:  true,
		},
	}
	for _, test := range tests {
		t.Run(test.description, func(t *testing.T) {
			schema := &schema{}
			actualEntity := schema.get(test.EntityName)
			assert.Equal(t, test.expectedEntity, actualEntity.entity)
			assert.Equal(t, test.expectedError, actualEntity.err != nil)
		})
	}
}

func TestFillSchema(t *testing.T) {
	tests := []testSchema{
		{
			description:    "should return a schema with nil instance and error when and schema's instance has not been generated previously",
			EntityName:     "",
			data:           emptyData,
			check:          false,
			expectedEntity: nil,
			expectedError:  true,
		},
		{
			description:    "should return a schema with oauth instance and error when data is empty",
			EntityName:     OAuth,
			data:           emptyData,
			check:          false,
			expectedEntity: &schemas.OAuthSchema{},
			expectedError:  true,
		},
		{
			description:    "should return a schema with oauth instance and error when data is mal formed to be parsed by json.Marshal",
			EntityName:     OAuth,
			data:           malFormedData,
			check:          false,
			expectedEntity: &schemas.OAuthSchema{},
			expectedError:  true,
		},
		{
			description: "should return a schema with filled oauth instance and nil error when all is ok",
			EntityName:  OAuth,
			data:        fakeData,
			check:       false,
			expectedEntity: &schemas.OAuthSchema{
				ID: uuid4.String(),
			},
			expectedError: false,
		},
	}
	for _, test := range tests {
		t.Run(test.description, func(t *testing.T) {
			s := schema{}
			actualEntity := s.get(test.EntityName).fill(test.data)
			assert.Equal(t, test.expectedEntity, actualEntity.entity)
			assert.Equal(t, test.expectedError, actualEntity.err != nil)
		})
	}
}

func TestValidateSchema(t *testing.T) {
	tests := []testSchema{
		{
			description:    "should return a schema with nil instance and error when and schema's instance has not been generated previously",
			EntityName:     "",
			data:           emptyData,
			check:          true,
			expectedEntity: nil,
			expectedError:  true,
		},
		{
			description: "should return a schema with oauth instance and error generated by validate in check process",
			EntityName:  OAuth,
			data:        badData,
			check:       true,
			expectedEntity: &schemas.OAuthSchema{
				ID: "baddata",
			},
			expectedError: true,
		},

		{
			description: "should return a schema with filled oauth instance and nil error when all is ok",
			EntityName:  OAuth,
			data:        fakeData,
			check:       true,
			expectedEntity: &schemas.OAuthSchema{
				ID: uuid4.String(),
			},
			expectedError: false,
		},
	}
	for _, test := range tests {
		t.Run(test.description, func(t *testing.T) {
			s := schema{}
			actualEntity := s.get(test.EntityName).fill(test.data)
			if test.check {
				actualEntity.validate()
			}

			assert.Equal(t, test.expectedEntity, actualEntity.entity)
			assert.Equal(t, test.expectedError, actualEntity.err != nil)
		})
	}
}
